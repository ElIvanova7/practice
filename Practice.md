# Мобильное клиент-серверное приложение «Ювелирный магазин»
***Описание приложения:*** удобное мобильное приложение, которое позволяет выбирать и заказывать украшения прямо со смартфона. 
***Функциональные требования***
1.	Аутентификация пользователя и управление учетными записями: 
*	Регистрация: пользователи должны иметь возможность создавать учетные записи с действительными адресами электронной почты и безопасными паролями.
*	Вход: пользователи должны иметь возможность войти в свои учетные записи, используя свои учетные данные.
*	Управление профилем: пользователи должны иметь возможность управлять информацией своей учетной записи, такой как имя, адрес и платежные данные.
*	Сброс пароля: пользователи должны иметь возможность сбросить свои пароли, если они забыты.

2.	Просмотр и поиск: 

*	Список товаров: приложение должно отображать комплексный каталог предметов ювелирных изделий с четкими описаниями, изображениями и ценами.
*	Фильтрация: пользователи должны иметь возможность фильтровать и сортировать продукты на основе критериев, таких как категория, ценовой диапазон и т.д.
* Функция поиска: пользователи должны иметь возможность искать конкретные товары по ключевым словам.
*	Сведения о товаре: пользователи должны иметь возможность просматривать подробную информацию о каждом товаре, включая описания, изображения и отзывы других пользователей.

3.	Корзина для покупок и оформление заказа: 

*	Добавление в корзину: пользователи должны иметь возможность добавлять товары в свою корзину.
*	Управление корзиной: пользователи должны иметь возможность просматривать и изменять свое содержание корзины, включая настройки количества и удаление товаров.
*	Процесс оформления заказа: пользователи должны иметь возможность завершить процесс оформления заказа с помощью безопасных вариантов оплаты.
*	Подтверждение заказа: пользователи должны получать электронные письма о подтверждении заказа с информацией о заказе и его статусом.

4.	Управление заказами и отслеживание: 

*	История заказов: пользователи должны иметь возможность получить доступ к своим прошлым заказам с подробной информацией о каждом приобретенном товаре.
*	Отслеживание заказов: пользователи должны иметь возможность отслеживать статус своих заказов в режиме реального времени.

5.	Персонализация и рекомендации: 

*	Избранное: пользователи должны иметь возможность создавать списки желаний (избранное) и управлять ими.
*	Рекомендации по товарам: приложение должно рекомендовать товары на основе истории просмотра пользователей и их предпочтений.

6.	Безопасность и конфиденциальность: 

*	Шифрование данных: все пользовательские данные должны быть надежно зашифрованы.
*	Безопасная обработка платежей: приложение должно использовать защищенные платежные шлюзы для защиты информации пользователей.
*	Политика конфиденциальности: приложение должно иметь четкую и краткую политику конфиденциальности, которая описывает, как собираются и используются пользовательские данные.

***Нефункциональные требования***     
1. Производительность:

*	Гладкая навигация: навигация между экранами должна быть плавной и интуитивно понятной, с минимальным временем загрузки.
*	Загрузка изображения: изображения товаров должны загружаться быстро и эффективно, даже на экранах с низким разрешением.

2.	Надежность: 

*	Безопасность данных: приложение должно защищать пользовательские данные, включая информацию о платежах, с надежными мерами безопасности.
*	Обработка ошибок: приложение должно корректно обрабатывать ошибки и предоставлять информирующие сообщения пользователю.

3.	Удобство использования:

* Интуитивно понятный интерфейс: приложение должно иметь удобный интерфейс, который легко воспринимается пользователями.
* Настройки: пользователи должны иметь возможность настроить приложение в соответствии с их предпочтениями, такими как язык, настройки уведомлений и т.д.

4.	Безопасность:

* Аутентификация: должны быть реализованы процессы безопасного входа и регистрации.
* Авторизация: доступ пользователя к различным функциям должен контролироваться на основе их разрешений.

### Моделирование бизнес-процесса
Для моделирования бизнес-процесса создания заказа использовалась нотация BPMN.      
![BPMN_схема](https://github.com/ElIvanova7/practice/assets/174890032/84888c78-94c9-4392-aaff-6567eefb1942)
Поступает запрос от клиента на создание заказа, после чего приложение отсылает запрос на проверку наличия на складе выбранных товаров: если все в наличии, то продолжаем работу с заказом и высылаем клиенту форму оплаты, которая действительна 10 минут. По истечении этого времени, если оплата не была произведена, заказ признается недействительным и отменяется. Если же оплата прошла успешно, то клиенту высылается сообщение об успешном создании заказа. 

### Описание процесса синхронизации данных между клиентом и сервером с помощью UML диаграмм
* Создание, редактирование и отмена заказа:
![управление_заказами](https://github.com/ElIvanova7/practice/assets/174890032/238a3a2c-95d4-4250-a76b-c11e82347a28)
* Изменение персональных данных:
![обновление_данных](https://github.com/ElIvanova7/practice/assets/174890032/73f3bb19-d2f3-4b9d-a5fd-c63a77c13451)
* Оплата заказа:
![оплата_заказа](https://github.com/ElIvanova7/practice/assets/174890032/242dfc2a-074b-490e-8a5d-6674a9ecfdb9)

### Синхронизация данных между клиентом и сервером с использованием методов API
*1. Аутентификация пользователя* 
*	Метод API: POST/api/login
*	Запрос Body: {"username": "user1", "пароль": "пароль123"}
*	Ответ: {"token": "your_generated_token", "user_id": 123}
- Описание: клиенты аутентифицируют подлинность, используя свои учетные данные. Сервер генерирует токен для безопасной связи и идентифицирует пользователя.
-  Синхронизация: информация пользователя загружается на основе полученного user_id.

*2. Создание заказа*
*	Метод API: POST/api/orders
*	Запрос Body: {"user_id": 123, "Товары": [{"product_id": 456, "Количество": 2}, ...], "customer's address": {...}}
*	Ответ: {"order_id": 789}
-  Описание: клиент отправляет запрос на заказ, в запрос включены пользовательская информация, информация о товарах и адрес доставки.
-  Синхронизация: сервер создает заказ и назначает order_id, который отправляется обратно клиенту.

*3. Редактирование заказа* 
*	Метод API: PUT/api/orders/{order_id}
*	Запрос Body: {"Товары": [{"product_id": 456, "Количество": 1}, ...], " customer's address ": {...}}
*	Ответ: {"Сообщение": "Заказать обновлен успешно"}
-  Описание: клиент отправляет обновленную информацию для конкретного заказа.
-  Синхронизация: сервер обновляет данные заказа в своей базе данных и информирует клиента.

*4. Отмена заказа*
*	Метод API: DELETE /api/orders/{order_id}
*	Запрос Body:  -
*	Ответ: {"Сообщение": "Заказ успешно отменен"}
-  Описание: клиент отправляет запрос на отмену заказа.
-  Синхронизация: сервер обновляет состояние заказа и информирует клиента.

*5. Изменение личных данных* 
*	Метод API: PUT/user/{user_id}
*	Запрос Body: {"name": "Новое имя", "Электронная почта": "new.email@example", "Номер телефона": "+7 987 777 77 77"
*	Ответ: {"Сообщение": "Информация пользователя успешно обновлена"}
-  Описание: клиент отправляет обновленную личную информацию.
-  Синхронизация: сервер обновляет данные пользователя и информирует клиента.

*6. Процесс оплаты*
*	Метод API: POST/orders/{order_id}/pay
*	Запрос Body: {"payment": "card", "card_details": {...}}
*	Ответ: {"transaction_id": "your_transaction_id", "status": "успех/неудача"}
-  Описание: клиент отправляет платежную информацию.
-  Синхронизация: сервер обрабатывает платеж, обновляет статус заказа и информирует клиента о результате транзакции.


### ER-диаграмма сущностей
![er-диаграмма](https://github.com/ElIvanova7/practice/assets/174890032/45aa1a4d-9adb-4ca9-b800-cb4393bf0886)      
На данной ER-диаграмме присутствуют следующие сущности:   
пользователь - представляет собой человека, который делает заказы;   
заказ - представляет собой информацию о заказе, который сделал пользователь;   
доставка - представляет информацию о доставке заказа;   
оплата - представляет информацию об оплате заказа;   
товар - представляет информацию о товаре, который пользователь может заказать.    

Сущности связаны между собой следующим образом:   
- пользователь может сделать один или несколько заказов;   
- пользователь может иметь несколько доставок;  
- заказ может содержать один или несколько товаров;   
- заказ может иметь одну доставку.   

### Прототипы экранов мобильного приложения «Ювелирный магазин»
  **Прототип экрана регистрации для новых пользователей**     

![2024-07-07_16-33-30](https://github.com/ElIvanova7/practice/assets/174890032/e86cfa67-5909-4a02-b8a1-51292320b937)   
Чтобы использовать все функции приложения пользователю необходимо иметь аккаунт. Для регистрации необходимо ввести адрес электронной почты и придумать пароль. Далее пользователь нажимает на кнопку "Зарегистрироваться". Если у пользователя уже есть аккаунт, то с этого экрана он может перейти на страницу входа, нажав на кнопку "Войти" внизу экрана.    

  **Прототип экрана корзины (процесс оформления заказа)**   

![2024-07-07_18-11-23](https://github.com/ElIvanova7/practice/assets/174890032/c473333c-f2fc-4395-b331-385caff66322)   
Пользователь создает заказ при помощи корзины, из каталога товары добавляются в нее. Здесь же пользователь может выбрать адрес доставки: по умолчанию будет стоять адрес, указанный пользователем в его профиле (если указан) или же можно ввести любой другой, соответствующий радиусу доставки. Также в корзине отображаются товары с краткой информацией для удобства пользователя, предусмотрена функция удаления из корзины. Указана полная стоимость заказа: "Итого к оплате:". Для оформления заказа необходимо нажать на кнопку "Оформить заказ", после чего пользователь будет перенаправлен на страницу оплаты. 


### Описание функции редактирования заказа
Функция редактирования заказа позволяет пользователю изменить детали существующего заказа в приложении. Для разработки этой функции потребуется создать соответствующие API методы и обеспечить хранение информации о заказах пользователя в базе данных.   
**Задача:** Редактирование заказа пользователем.   
**Описание:** Пользователь должен иметь возможность изменить детали своего существующего заказа, такие как товары, количество товаров, адрес доставки и прочее.     
**User story:** Я, как пользователь приложения «Ювелирный магазин», хочу иметь возможность редактировать свой заказ, чтобы получить заказ в соответствии с своими ожиданиями (в правильном количестве товаров, соответствующей цене и по верному адресу).    
Алгоритм действий:    
1. пользователь открывает детали заказа в своем аккаунте;   
2. пользователь нажимает кнопку "Редактировать заказ";  
3. пользователь вносит необходимые изменения;  
4. пользователь сохраняет изменения.   

**UML диаграмма:**    
![изменение_заказа](https://github.com/ElIvanova7/practice/assets/174890032/2b7900a3-3654-4a56-889b-67a13f19df4f)

**Редактирование заказа:**  
*	Метод API: PUT/api/orders/{order_id}
*	Запрос Body: {"Товары": [{"product_id": 456, "Количество": 1}, ...], " customer's address ": {...}}
*	Ответ: {"Сообщение": "Заказать обновлен успешно"}
-  Описание: Клиент отправляет обновленную информацию для конкретного заказа.   
-  Синхронизация: Сервер обновляет данные заказа в своей базе данных и отправляет клиенту успешное сообщение.   

**Хранение информации о покупках пользователя:**
Для хранения информации о заказах пользователя в базе данных можно создать таблицу "orders", содержащую следующие поля:
* order_id (идентификатор заказа)
* user_Id (идентификатор пользователя, сделавшего заказ)
* products (информация о выбранных товарах)
* quantity (количество каждого продукта)
* deliveryAddress (адрес доставки)
* totalAmount (общая сумма заказа)
При добавлении нового заказа, новая запись будет добавляться в таблицу "orders". При редактировании заказа, существующая запись будет обновляться в соответствии с внесенными изменениями.    
Таким образом, функция редактирования заказа позволит пользователям легко и удобно изменять свои заказы, а хранение информации о заказах в базе данных обеспечит надежность и доступность данных о заказах.   

### SQL-запросы к реляционной модели данных:
![111](https://github.com/ElIvanova7/practice/assets/174890032/80da5318-4514-4ac9-ac60-3a046be115e2)
**Вывод покупателей с количеством осуществлённых покупок:**    

*SELECT Покупатели.Идентификатор, Покупатели.Имя, Покупатели.Фамилия,
COUNT(Покупки.Идентификатор) AS 'Количество покупок'    
FROM Покупатели    
LEFT JOIN Покупки ON Покупатели.Идентификатор = Покупки.ключ_покупателя   
GROUP BY Покупатели.Идентификатор, Покупатели.Имя, Покупатели.Фамилия*      

**Вывод общей стоимости товаров для каждого покупателя, отсортированных в порядке убывания:**   

*SELECT Покупатели.Идентификатор   
SUM(Товары.Стоимость) AS 'Общая стоимость'   
FROM Покупатели   
JOIN Покупки ON Покупатели.Идентификатор = Покупки.ключ_покупателя   
JOIN Товары ON Покупки.ключ_товара = Товары.Идентификатор   
GROUP BY Покупатели.Идентификатор   
ORDER BY 'Общая стоимость' DESC*   
  
**Вывод покупателей, купивших только один товар:**   

*SELECT Покупатели.Идентификатор, Покупатели.Имя, Покупатели.Фамилия   
FROM Покупатели   
JOIN Покупки ON Покупатели.Идентификатор = Покупки.ключ_покупателя  
GROUP BY Покупатели.Идентификатор, Покупатели.Имя, Покупатели.Фамилия   
HAVING COUNT(Покупки.ключ_товара) = 1*   
  






















  




